<!DOCTYPE html>
<html lang="en">
<head>
<title>Stephen Bolt - Code</title>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width">
<link href="../css/styles.css" rel="stylesheet" type="text/css" media="all">
<link href="http://fonts.googleapis.com/css?family=Ubuntu:regular,bold" rel="stylesheet" type="text/css">
<link href="http://fonts.googleapis.com/css?family=Vollkorn:regular,italic,bold" rel="stylesheet" type="text/css">
<link rel="icon" href="../favicon.ico" type="image/x-icon" />
<link rel="shortcut icon" href="favicon.ico" type="image/x-icon" />
<!--[if lt IE 9]>
<script src="js/html5.js"></script>
<script src="js/IE9.js"></script>
<![endif]-->
</head>
<body>
<div id="headerwrap">
  <header id="mainheader" class="bodywidth clear"> <img src="../images/steve_bw_60x60.jpg" alt="photo" class="logo">
    <hgroup id="websitetitle">
      <h1 style="padding-top:6px;"><span class="bold">Stephen Bolt</span></h1>
      <h2 style="padding-top:2px;">My Code</h2>
    </hgroup>
    <nav>
      <ul>
        <li><a href="../index.html">Home</a></li>
      </ul>
    </nav>
  </header>
</div>

<div id="maincontent" class="bodywidth clear" style="border-top:none; padding-bottom: 0px">
  <h2 class="blue" style="padding: 6px 0 12px 0; font-size: 2.3em"><span class="bigblueheader">My Code</span></h2>
  <div id="aboutleft">

    <h3>What I've Been Building...</h3>
    <p>
       Across the last 10 years I have been building a codebase for the purpose of rapid application development. While I have built numerous applications with this
       codebase, myy focus has really been on the parts of applications that are typically thought of last.</p>
    <p>It is very natural and necessary to focus on the primary/core functions when developing new applications. But any application that needs
       to be "production grade" requires a robust set of "secondary/supporting functions" in order to operate properly.</p>
    <p>These secondary functions include such things as configuration, logging, encryption, serialization, date processing, 
       interfaces to web services and databases, file processing algorithms, messaging, exception handling, email and SMS notifications, modularity, task 
       processing, etc. 
    </p>
    <p>
       Taken as a whole this set of elements can comprise more than 50% of the final code in an application - sometime much more.  Most of these functions 
       support some aspect of the "operational function" of the technology, not necessarily the primary "business function".  The primary "business function" pertains to 
       <span style="font-style:italic;text-decoration: underline;">what</span> an application must do.  The "operational function" pertains to 
       <span style="font-style:italic;text-decoration: underline;">how</span> an application accomplishes its primary business function - or how it delivers its value. 
    </p>
  </div>


  <section id="articlesright" style="padding-top:40px;">
    <article>
      <figure> <img src="../images/c-sharp-apps.png" alt=""> </figure>
      <header><a href="https://github.com/smbolt/smbolt_git/tree/master/code/CS/Apps" target="_blank">
        <h5>C# Generic/Utility Applications</h5>
        </a></header>
      <p>A set of utility programs and application shells that perform focused functions or serve as a platform for reusable component development.</p>
      <br/>
    </article>

    <article style="padding-top:20px;">
      <figure> <img src="../images/reusable-libs.png" alt=""> </figure>
      <header><a href="https://github.com/smbolt/smbolt_git/tree/master/code/CS/Libs" target="_blank">
        <h5>Reusable C# Libraries</h5>
        </a></header>
      <p>A large set of reusable libraries that provide various types of support for multiple types of applications.  A significant 
         amount of commonly needed application functionality is implemented in the "General Services Library" - Org.GS.</p>
    </article>
  </section>

</div>


<div  id="fullwidthcontent" class="bodywidth clear" style="border-top:none; padding-top: 0px;">
  <p>
     My philosophy is that <span style="font-style:italic;text-decoration: underline;">all</span> the business value potential of an application is realized through 
     its <span style="font-style:italic;text-decoration: underline;">operation</span> (when it operates, it produces value, when it's broken no value is produced, 
     only disruption). Therefore building solid, reusable components that implement the operational aspects of applications is very important part of being 
     able to deliver business value.  Further, building them <span style="font-style:italic;text-decoration: underline;">once,</span> as reusable components fosters the 
     kind of reuse, that coupled with the willingess to refactor and make fixes in the right place, produces a very solid and nicely architected set of components. 
     Having a library of such components enables the production of high-quality applications that are developed fairly rapidly - two things that do not normally go together.
  </p>
  <p>
     It is very common for these "operational" needs to be built in an ad-hock fashion as a secondary, lower-priority focus of the development process. 
     This typically results in a wide diversity of techniques being used to solve the the same common set problems - or fairly often, such applications 
     end up "doing without" some of the operational support they should have. This diversity of approach when solving common problems leads to minimal reuse. 
     And, minmal reuse substantially cuts off the opportunity to drive continual improvement - and this leads to buggy software.
  </p>
  <p>
     When I start a new job or engagement, I always ask whether any shared libraries exist (perhaps someone has invented the wheel by now) for handling 
     these very common application support needs.  If they they do exist, then I would certainly use them rather the coding something different from scratch and 
     propagating unnecessary variation. But with only one notable exception I never found what I was looking for and have ended up needing to create some of these 
     functions from scratch - yet again. After having this occur a few times I decided that I would simply "bring my code with me" and offer to give it to the 
     organization or project so that I could prevent the need to build again these common support functions and could be free get started building the applications 
     which were the purpose for which I had been hired. 
  </p>
  <p>
     I have coded well over a hundred "home projects" (for learning or for a specific purpose) and have done a number of side projects of various sizes across the last
     ten years.  Across this span of time I have continued to build up and perfect this set of reusable components.  Additionally I have also developed a number 
     of "application shells" for desktop applications, Windows Services and WCF web services.  With these "shells" I have a good starting place for applications of 
     various "form factors" and I thus don't have to start from scratch at the higher levels either.  Additionally, there is a set of commonly needed utilities.</p>
  <p>
     As an example of what I've been discussing, I have placed below a somewhat detailed discussion of one of the "application shells" - it is a Generic Task Processing 
     Windows Services which I call "TPFX" the "Task Processing Framework".
  </p><br/>

  <h3>Example - Generic Task Processing Framework</h3>
  <p>
     As an example of an "application shell" which uses several of the operational libraries discussed above, this section discusses a generic task processing framework 
     that I call "TPFX" (Task Processing Framework). For a high-level view of the functionality of the TPFX, please see the diagram at the bottom of this page.
  </p>
  <p>
     You can find the code for the top-level Windows Service application in the "WinService" folder in the "Apps" top level folder in the code repository 
     (see the "Code" links).  There is also an application in the "Apps" folder called "WinServiceHost".  WinServiceHost is a desktop application that contains 
     all the "child libraries" for the task processing service and serves as a platform for the development and testing of the service.
     Windows Services do not have a user interfaces (they run as the background processes controlled by the operating system with no visible components) 
     and are therefore difficult to develop and debug. The WinServiceHost program "hosts" all of the components of the Task Processing Framework 
     and thus makes development and testing much easier.
  </p>
  <p>
     Embodying the entire functionality of the TPFX within high-level libraries and then running them inside a desktop application (WinServiceHost) allows a user 
     interface "surface" for clicking buttons and viewing a scrolling log of activity and messages as output.  This allows the actual service, WinService, to be 
     the thinnest wrapper between the operating systems Service Control Manager and the high-level libraries where the controlling algorithms run.  
     This also makes the entire application very portable concering what kind of wrapper it runs in.
  </p>
  <p>
     In addition to the top-level (main-thread-owning) applications, a number of reusable (thread-dependent) components in the "Libs" folder of the codebase are 
     used by the TPFX. This includes high-level components such as including Org.TSK (implementing the task engine and task dispatcher) and Org.TSK.Business 
     (the business classes related to task processing, scheduling parameterization, etc.).  Additional lower level libraries include Org.TP (base classes and 
     interfaces for task processors), Org.Notify (email and SMS notifications), and as always, at the bottom of the hierarchy is Org.GS (providing a broad array 
     of services - too many to list here, but most are organized into folders under the Org.GS folder if you want an genearl idea) supporting the most common 
     services to all types of applications and mid/lower-level libraries across the codebase). 
  </p>
  <p>
     In the diagram below the generic and reusable code is represented by everything that is not blue.  The unique task processing modules which are dynamically 
     plugged in at run-time are the items in blue. These "blue modules" are the <span style="font-style:italic;text-decoration: underline;">only code that needs 
     to be written</span> to implement a new function (regardless how simple or complex - to this architecture, they are all just "blue modules" that "plug in" 
     to the higher level framework). What this means is that about 95% of the code is generic and completely reusable. It is also quite well perfected since 
     it has been used, fixed, optimized, etc. repetitively across several years.
  </p>
  <p>
     To implement a new instance of this service, you simply copy the binaries of the service to a new directory, run a PowerShell commmand to create a new Windows Service 
     definition pointing at the main executable, move some "blue modules" (containing the desired business functions) into a subordinate directory so they can be 
     discovered and loaded, update the database with scheduling and any required parameters and notification configurations, update the service's main configuration 
     file to tell the service tasks in the schedule it is responsible for... then simply start the service using the operating system's Service Control Manager. 
  </p>
  <p>
     Building new modules can be done very rapidly because they all adhere to a very simple interface and follow a consistent pattern of structure and behavior.  
     You don't have to build anything that surrounds the "blue module": scheduling, parameterization, logging, configuration, exception handling, 
     notifications, a multi-threaded engine and more are all part of the very capable "socket" in which the modules run - which is fully reusable and doesn't
     have to know about or be responsible for any business functionality that the modules implement.
  </p> 
  <p>
     With these libraries I can focus on delivering <span style="font-style:italic;text-decoration: underline;">business value</span> instead of building 
     <span style="font-style:italic;text-decoration: underline;">again</span> the necessary <span style="font-style:italic;text-decoration: underline;">operational overhead</span> 
     functions for applications.  And from an operations standpoint (concerning security, stability, reliability, performance, threading and much  more), 
     I like to say (because it has been my objective in building this) "it runs like a refrigerator" - by which I mean, it just sits there and hums, 
     doesn't cause any trouble and simply gets its work done on time. 
  </p> 
  <p> 
     The Task Processing Framework (TPFX) is simply a completely generic and totally reusable framework. It is completely focused on providing business value by 
     enabling business-value-creating modules to be developed very quickly. These value-creating modules thus have a solid "run-time home" and are freed from having  
     to worry about (or even to know about) anything that exists outside of each module's specific <span style="font-style:italic;text-decoration: underline;">
     business-value-providing</span> concerns. Everything else is provided by the framework.  All of the <span style="font-style:italic;text-decoration: underline;">
     opertional</span> requirements have been met in a scope that is fully outside the visibiliy and concerns of the business-focused modules. 
  </p>
  <p>
    <span style="font-style:italic;text-decoration: underline;">This</span> is what I mean what I speak of (application systems) architecture. And this is the kind
    of stuff I am referring to when I talk about technology finding its purpose in being totally focused on providing business value.
  </p>
  <br/>

  <img src="../images/tpfx.png" alt="" class="shadow" width="100%"  style="margin-bottom:30px">
</div>



<div id="footerwrap">
  <footer id="mainfooter" class="bodywidth clear">
    <nav class="clear">
      <ul>
        <li><a href="../index.html">Home</a></li>
      </ul>
    </nav>
  </footer>
</div>

</body>
</html>
